= Kafka : an introduction

Kafka is a publish/subscribe messaging system in which a *producer* writes messages on a *topic* (a topic is a group of messages of the same category) and a *consumer* read these messages asynchronously.

[.text-center]
image::kafka/pub-sub.png[]

The image above shows a producer that has published _n_ messages on a topic and a consumer that handles them at its pace. The publisher doesn't wait the consumer to read messages to continue what it as to do. Actually the publisher doesn't even care if there one, several or no consumers at all. The writing and reading of these messages are totally *asynchronous*.

Without that kind of system it would mean that if components `B`, `C`, `D` are interested and a certain `E` generated by `A`, every time `E` occurs, `A` would have know who is interested by this event and notify them. As the image below illustrates this introduces coupling between components. In contrast by using a publish/subcribe system like Kafka the producer has only one dependency no matter how many components are interested by the event `E`.

[.text-center]
image::kafka/pub-sub-with-without.png[]

The main advantage of this kind of system is that it allows you to build *loosly coopled* components.

There many systems implementing publish/subscribe patterns but the reasons to choose kafka are because it is:

* distributed
* scalable
* fault-tolerant
* high-performant

== Kafka is distributed

Kafka is built to be deployed on several servers. Each instance of Kafka is called a *broker* and all the brokers from a *cluster*. Messages of a topic can be written and read to and from any broker of the cluster. Kafka distributes a topic accross a cluster by splitting it into *partitions*. The next figure shows the topic _"my-events"_ splitted into 3 partitions each one on a broker.

[.text-center]
image::kafka/distributed.png[]

A message is kafka is called a *record* and is composed by a *key* and a *value*. The *value* is the content of the message. When a record is published it is written on a partition. 

Due to its distributed nature Kafka cannot guarantee that a consumer of a topic receives records in the order in which they were written. In other words *it cannot guarantee the global time-ordering of the records on a topic. It only guarantees the ordering for the records in the same partition.*

In some context this constraint may be really important and it may be mandatory for a group a records to be on the same partition. By default Kafka uses a hash of the record key to determine on which partition it has to write it. Kafka guarantees that all messages having the same hash will be written on the same partition. 

== kafka is scalable

=== Consumer

Each message on a partition has a unique identifier called the *offset*. The consumer of a topic uses this offset to keep track of which messages it has read on each partition. Kafka allows you horizontally scale the processing of a topic by having multiple instances of the same consumer. This *consumer group* assures that a partition consumed by only one consumer. In other words this mechanism assures that a message is read and processed only once by the group.

[.text-center]
image::kafka/consumer-group.png[]

If you want to have another application consuming the same topic you have to group the instances in a new consumer group.

== Kafka is fault-tolerant

* no transient messages 
* replication

[.text-center]
image::kafka/replicas.png[]

=== Consumer
_if a single consumer fails, the remaining members of the group will rebalance the partitions being consumed to take over for the missing member_